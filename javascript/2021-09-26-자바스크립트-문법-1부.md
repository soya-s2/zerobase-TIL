# 2021-09-26-Sun

<br/>

## 2. 자바스크립트 기본 문법-1부

### 🐶 변수와 상수

변수 선언은 `let` 키워드, 상수 선언은 `const` 키워드로 한다.

<br/>

- **let**  
  **변경 가능한 값을 저장**하며, 사용 전 선언해야 한다.  
  중복 선언이 불가능한데, 이는 변경의 의미가 아니다.  
  즉 `let num = 0;` 이후 `let num = 2;`과 같은 재선언이 불가하다는 의미이며,  
  `num = 2;`와 같은 **재할당은 가능**하다.  
  `let a = 1, b = 2, c = 3;`과 같은 한 줄에 여러 변수 선언이 가능하다.

<br/>

- **const**  
  **변경 불가한 값을 저장**하며, 사용 전 선언해야 한다.  
  보통은 대문자로 표기하는 것이 좋다.  
  중복 선언이 불가능하며, **값의 재할당도 불가**하다.  
  변하지 않는 값을 저장하므로 변경될 수 없기 때문이다.  
  그리고 `const`는 선언과 동시에 초기화가 이루어져야 한다.

<br/>

- **실습**

```js
// 선언 후 할당
let a;
a = 1;

// 선언 동시 초기화
let b = 2;

// 여러 변수 선언과 초기화
let c = 3,
  d = 4,
  e = 5;

// 상수 선언
const A = 1;

/* 오류 발생 부분
const B;
B = 2;

SyntaxError: Missing initializer in const declaration
*/
```

<br/>

---

<br/>

🐥 변수에는 **`호이스팅`** 이라는 개념이 있는데,  
변수나 함수가 코드 상단으로 끌어 올려져 예상과는 다른 출력이 나올 수 있다.  
예를 들어 변수 사용 코드가 변수 선언 코드보다 위에 있어도 오류가 나지 않는 케이스가 있다.  
호이스팅이 일어나는 이유는 자바스크립트의 실행 컨텍스트 때문인데,  
변수 선언과 초기화가 각각 분리되어 일어나기 때문이다.

<br/>

먼저 **변수 호이스팅**부터 실습해본다.

<br/>
<br/>

#### 🐣 변수의 호이스팅

```js
// 매개변수와 변수에 대한 호이스팅 - 원본 코드

function a(x) {
  // 수집 대상 1 (매개변수)
  console.log(x); // (1)
  var x; // 수집 대상 2 (변수 선언)
  console.log(x); // (2)
  var x = 2; // 수집 대상 3 (변수 선언)
  console.log(x); // (3)
}
a(1);
```

<br/>

수집 대상은 함수의 매개변수, 변수 선언 부분이 있다.  
호이스팅 될 때는 어떤 식별자가 있는지에만 관심을 둔다.  
그러므로 변수명만 끌어올리고 할당 과정은 원래 자리에 남겨둔다.  
그러므로 위의 코드는 아래와 같이 호이스팅 된다.  
`a(1);`은 `var x = 1;`과 같이 간주한다.

<br/>
<br/>

```js
// 호이스팅 결과

function a() {
  var x; // 수집 대상 1의 변수 선언 부분
  var x; // 수집 대상 2의 변수 선언 부분
  var x; // 수집 대상 3의 변수 선언 부분

  x = 1; // 수집 대상 1의 할당 부분
  console.log(x); // (1)
  console.log(x); // (2)
  x = 2; // 수집 대상 3의 할당 부분
  console.log(x); // (3)
}
a(1);
```

<br/>

출력 결과는 `1, 1, 2`가 된다.  
다음으로 **함수의 호이스팅**을 실습해본다.

<br/>
<br/>
<br/>

#### 🐣 함수의 호이스팅

```js
// 함수 선언의 호이스팅 - 원본 코드

function a() {
  console.log(b); // (1)
  var b = "bbb"; // 수집 대상 1 (변수 선언)
  console.log(b); // (2)
  function b() {} // 수집 대상 2 (함수 선언)
  console.log(b); // (3)
}
a();
```

<br/>

함수는 함수 선언문인지, 함수 표현식인지에 따라 달라진다.  
함수 선언문은 `function name() {};`과 같은 형태이고,  
함수 표현식은 `var name = function() {};`과 같은 형태이다.  
함수 선언문은 호이스팅이 발생하고, 표현식은 정확하게 말하면 **변수** 호이스팅이 발생한다.  
다음은 호이스팅 결과이다.

<br/>
<br/>

##### 🐤 함수 선언문의 호이스팅

```js
function a() {
  var b; // 수집 대상 1. 변수는 선언부만 끌어올림
  function b() {} // 수집 대상 2. 함수 선언은 전체를 끌어올림

  console.log(b); // (1)
  b = "bbb"; // 변수의 할당부는 원래 자리에 남겨둠
  console.log(b); // (2)
  console.log(b); // (3)
}
a();
```

<br/>

함수 선언문은 선언부 전체를 끌어올린다는 특징을 눈여겨 봐야한다.  
출력 결과는 `[Function: b], bbb, bbb`가 된다.  
그렇다면 함수 표현식은 어떻게 되는지 궁금해서 실습해보았다.

<br/>
<br/>

##### 🐤 함수 표현식의 호이스팅

```js
function a() {
  console.log(b); // (1)
  var b = "bbb"; // 수집 대상 1 (변수 선언)
  console.log(b); // (2)
  var b = function b() {}; // 수집 대상 2 (함수 선언)
  console.log(b); // (3)
}
a();

/* 아래와 같이 호이스팅 된다. 
function a() {
  var b;
  var b;
  console.log(b); // (1)
  b = "bbb"; // 수집 대상 1 (변수 선언)
  console.log(b); // (2)
  b = function b() {} // 수집 대상 2 (함수 선언)
  console.log(b); // (3)
}
a();
*/
```

<br/>

출력 결과가 달라졌다!  
기존의 출력 결과는 ~~`[Function: b], bbb, bbb`~~ 였으나,  
`undefined, bbb, [Function: b]`가 되었다.  
이는 **함수 표현식은 변수 선언만 끌어올렸기 때문이라고 볼 수 있다.**

<br/>

**`let/const` 변수 선언에서는 호이스팅이 발생하지 않는다.**  
호이스팅은 이해하기 어렵고 생소한 개념이었지만 아주 재밌었다. 🖐

<br/>
<br/>
<br/>
<br/>
<br/>

### 🐱 자료형

자료형이란 특정 성질, 범주를 가지고 있는 데이터를 분류한 것이다.  
우리의 자스는 6가지 원시 타입과 1가지 객체 타입으로 구성되어 있다.

<br/>

- **원시 타입(primitive type)**

  - **Boolean** / true, false
  - **null** / 존재하지 않거나 유효하지 않음(존재하지 않거나, 비어 있거나, 알 수 없거나)
  - **undefined** / 할당되지 않은 변수 또는 선언 후 초기화되지 않은 변수
  - **number** / 정수와 실수를 포함한 숫자, 2^53까지 표현 가능하다. Infinity, -Infinity, NaN을 포함하며, `2^53 - 1`보다 큰 값을 쓰려면 `bigint`를 써야 한다.
  - **string** / 문자열
  - **symbol** / 객체 속성 (ES6)

<br/>

- **객체 타입(object type)**

  - **object** / 키와 값으로 여러 개체들을 저장 가능한 타입  
    `Object()`, `{}`로 생성한다. `key: value` 형태로 표현하고,  
    `object.key` 형태로 접근한다.

<br/>
<br/>

_자료형은 `typeof x` 또는 `typeof(x)`로 확인 가능하다._  
특이한 점은 `typeof 456n`은 `bigint`,  
`typeof Math`와 `typeof null`이 `object`형이라는 점이다.  
메서드는 `function`으로 나온다.  
그 중 특히 `typeof null`이 `object`인 것은 하위 버전과의 호환성을 위해 표기한다.

<br/>

*실수들의 소수부 계산에서 정확도가 떨어지는 경우*가 있는데,  
이는 `toFixed(소숫점의 개수)`로 교정이 가능하며, 반올림 한다.

<br/>

*문자를 표현하는 방법*은 큰 따옴표, 작은 따옴표, 역 따옴표(백틱)가 있다.

<br/>
<br/>
<br/>
<br/>

### 🐭 객체 타입

다음과 같이 작성하는 것이 기본적인 문법이다.

```js
let me = {
  name: "kim",
  age: 26,
};

console.log(typeof me); // object
console.log(typeof me.name); // string
console.log(typeof me.age); // number

console.log(me); // { name: 'kim', age: 26 }
console.log(me.name); // kim
console.log(me["name"]); // kim
console.log(me.age); // 26

me.grade = 3;
console.log(me); // { name: 'kim', age: 26, grade: 3 }

delete me.age;
console.log(me); // { name: 'kim', grade: 3 }
```

<br/>
<br/>

이전에 객체란 키와 값으로 구성된 프로퍼티들의 집합이라고 했었다.  
`object` 타입은 참조형 데이터 타입에 속하며,  
이는 기본 데이터 타입과 차이가 있다.

<br/>

객체 타입은 객체의 변수 영역이 따로 존재하여,  
**객체 이름을 가진 공간 안에는 객체 내부의 키와 값들이 저장된 메모리 주소**가 들어있다.  
그러니까 기본형 데이터 타입보다 한 단계 더 거친 할당을 하는 셈이다.  
객체 영역에서는 키와 값을 가지고 있는 데이터들의 주소 묶음을 저장하는 것이다!

<br/>
<br/>
<br/>
<br/>

### 🐹 객체 복사 문제점

```js
let me = {
  name: "kim",
  age: 26,
};

let you = me;
console.log(you); // { name: 'kim', age: 26 }

you.age = 28;
console.log(you); // { name: 'kim', age: 28 }
console.log(me); // { name: 'kim', age: 28 }
```

<br/>

`let A = B;`와 같은 식으로 객체를 복사했으나,  
`you.age`의 값만 변하지 않고 원본 객체인 `me`의 `me.age` 조차 바뀌었다.  
그 **원인은 이런 방식의 객체 복사 시, 객체의 주소 값만 복사되기 때문**이다.

<br/>

위에서 객체 이름의 공간은 객체의 프로퍼티들이 들어있는 주소의 묶음을 가리킨다고 했는데,  
이 주소의 묶음을 똑같이 가리키게 되므로 값이 변경되면 영향을 미치는 것이다.  
즉 각자의 객체를 가지고 있는 것이 아니라는 것이다.  
이를 방지하기 위해 얕은 복사와 깊은 복사가 필요하다.

<br/>

위의 `me`, `you` 객체를 이용하여 얕은 복사와 깊은 복사를 하는 방법을 알아보겠다.

<br/>
<br/>

#### **얕은 복사 1**

for문으로 직접 하나하나 복사한다. **`객체[키] = 값`을 하면 `키: 값` 형태로 들어간다.**

```js
for (let key in me) {
  you[key] = me[key]; ⭐
}
```

<br/>

#### **얕은 복사 2**

`Object.assign`을 활용한다.  
이 메서드는 인자 안의 모든 속성을 복사해 객체에 붙여넣고 반환한다.  
즉 아래의 코드는 빈 객체와 `me` 객체의 프로퍼티들을 복사해 넣었으니 `me` 객체와 다름없다.

```js
let you = Object.assign({}, me); ⭐
```

<br/>

#### **얕은 복사 3**

spread 연산자를 이용한다.

```js
let you = { ...me }; ⭐ // { me.name, me.age }
```

<br/>

하지만 얕은 복사들은 객체 내에 다른 객체가 또 존재한다면 같은 문제가 발생한다.

<br/>
<br/>
<br/>
<br/>
