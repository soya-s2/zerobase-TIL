# 2021-09-30-Thu

<br/>

## 6. 수학 기본

### 👷 개요

코딩만 공부한다고 코딩 테스트를 다 풀 수 있는 것은 아니었다.  
즉 코딩테스트에 쓰이는 수학적 개념이 몇몇 있다.  
`경우의 수`, `점화식` 등이 그 예이다.  
이제부터 그 개념들을 차근차근 공부해본다.

<br/>
<br/>
<br/>
<br/>

### 👷 알고리즘 복잡도

알고리즘 성능을 평가하는 지표에는  
정확성, 작업량, 메모리 사용량, 최적성, 효율성(시간 복잡도, 공간 복잡도)이 있다.

<br/>
<br/>

알고리즘 복잡도 중의 시간 복잡도는  
알고리즘의 수행 시간을 평가하는 방법이다.  
빅오 표기법이라고 하여 `O(n)`으로 표기하는 방법,  
`세타`, `오메가` 등이 있다.  
연산에 따라 나오는 시간 복잡도에 있어서,  
입력되는 데이터의 개수에 따라 시간 복잡도가 굉장히 상승하는 경우가 있다.  
그림으로 보면 아래와 같다.

<br/>

<img src="../images/2021-09-30-시간복잡도.png">

<br/>
<br/>

`O(1)`은 입력 데이터와 관계 없이 시간이 일정한 반면,  
`O(n^n)`의 경우 어느 지점부터 기하급수적으로 상승하는 것을 볼 수 있다.  
그러므로 우리는 시간 복잡도가 낮은 알고리즘을 짜는 것이 좋다고 볼 수 있겠다.

<br/>

보통 반복문의 개수로 시간 복잡도를 대강 알 수 있을 때가 있다.  
for문이 1개인 간단한 프로그램을 예로 들면  
이 코드의 시간 복잡도는 `O(n)`이다.  
만약 이중 for문이라면 `O(n^2)`이 된다.

<br/>

**for문이 하나라고 해서 시간 복잡도가 항상 `O(n)`인 것은 아니고**,  
`i = 0`부터 n 이전까지의 반복을 했을 때가 그러하다.  
예시로 `for (let i = 0; i < n; i = i * 2)` 인 경우,  
n번의 연산이 아닌 n/2번의 연산을 하게 되는데  
이 때의 시간 복잡도는 `O(n)`이 아닌 `O(log N)`이 된다.

<br/>
<br/>
<br/>
<br/>

### 👷 경우의 수

`경우의 수`는 어떤 일이 일어날 수 있는 경우의 모든 가짓수를 표현하는 것이다.  
주사위의 경우 던지는 수는 1~6이므로 6가지이고,  
가위바위보는 가위, 바위 보의 3가지이다.

<br/>

하지만 _경우의 수도 조건에 따라 그 수가 달라질 수 있는데_,  
두 사람이 가위보를 했을 때 나올 수 있는 경우의 수는 총 9가지가 된다.  
이는 한 사람이 낼 수 있는 경우의 수인 3가지와  
나머지 한 사람이 낼 수 있는 경우의 수인 3가지를 곱하여 그렇게 된 것이다.

<br/>

이는 일상생활에서의 경우의 수이고,  
알고리즘에서는 `순열`, `조합`, `중복 순열` 등을 쓴다.  
**`순열`** 은 서로 다른 n개의 원소 중에서 r를 **중복 없이 골라 순서에 상관있게** 나열,  
**`조합`** 은 서로 다른 n개의 원소 중에서 r를 **중복 없이 골라 순서에 상관없이 나열**,  
**`중복 순열`** 은 위 두가지 개념을 합친  
서로 다른 n개의 원소 중에서 r개를 **중복을 포함하여 골라 순서에 상관없이 나열**하는 것이다.

<br/>

순열의 경우 1번, 2번, 3번의 사람을 줄 세우기 하는 것이 예시가 될 수 있다.  
조합의 경우 다양한 과일 중 n개를 뽑는 것이 있을 수 있다.  
이 때는 순서에 상관이 없다. 뽑은 사실 그 자체를 중시하는 것이다.  
아래에서 공부해본다.

<br/>
<br/>
<br/>
<br/>

### 👷 순열

**`순열`** 은 서로 다른 n개의 원소 중  
r를 중복 없이 골라 순서에 상관 있게 나열하는 경우의 수라고 하였다.

<br/>

`a`, `b`, `c`라는 알파벳 3개로 단어를 만드는 경우의 수가 그 예시이다.  
`abc`, `acb`, `bac`, `bca`, `cab`, `cba`로 6가지 경우가 될 것이다.  
처음에 a를 뽑으면 그 다음에는 b, c 중 하나가 올 수 있고,  
a와 b를 뽑으면 남는 것은 c 하나 뿐이다.  
즉 첫번째 뽑는 알파벳의 경우의 수가 3개,  
두번째는 2개, 3번째는 1개로 이들을 모두 곱하여 총 6개가 된다.  
코드로 실습해본다.

<br/>

```js
let input = ["a", "b", "c"];
let count = 0;

function permutation(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      if (i == j) continue;
      for (let k = 0; k < arr.length; k++) {
        if (i == k) continue;
        if (j == k) continue;

        console.log(arr[i], arr[j], arr[k]);
        count++;
      }
    }
  }
}

permutation(input);
console.log(count);
```

<br/>

위 예제는 반복문을 3중으로 구성해 가장 기본적으로 풀 수 있는 알고리즘이다.  
맨 앞부터 `input` 배열의 인덱스의 값에 접근하여  
a를 뽑았다면 그다음은 a를 뽑지 않도록 하였고,  
a와 b를 뽑았다면 aba와 abb를 뽑지 않도록 구성된 것이다.  
그 다음으로는 재귀적으로 함수를 구성하는 방법이 있다.

<br/>

```js
let input = ["a", "b", "c"];
let count = 0;

function permutation(arr, s, r) {
  if (s == r) {
    count++;
    console.log(arr.join(" "));
    return;
  }

  for (let i = s; i < arr.length; i++) {
    [arr[s], arr[i]] = [arr[i], arr[s]];
    permutation(arr, s + 1, r);
    [arr[s], arr[i]] = [arr[i], arr[s]];
  }
}

permutation(input, 0, 2);
console.log(count);
```

<br/>
<br/>
<br/>
<br/>

### 👷 조합

**`조합`** 은 서로 다른 n개의 원소 중에서  
r를 중복 없이 골라 순서에 상관 없이 나열하는 경우의 수라고 하였다.  
사실상 순열에서 `순서`를 고려하는 부분만 제외해주면 된다.  
카드 뽑기라고 가정하면, 달과 해 카드를 뽑았으면 그 순서는 상관이 없는 것이다.  
그러므로 4개의 카드 중 2개를 뽑는다고 가정하면  
12 13 14 23 24 34의 경우로 6가지가 가능하다.  
순서를 고려한다면 12 13 14 21 23 24 31 32 34 41 42 43으로  
12가지가 나와야 한다.  
이 예제를 아래 코드에서 공부해본다.

<br/>

```js
let input = [1, 2, 3, 4];
let count = 0;

function combination(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      count++;
      console.log(arr[i], arr[j]);
    }
  }
}

combination(input);
console.log(count);
```

<br/>

처음에 1번 카드를 뽑았다면 그 다음에는 1번 카드가 선택에서 제외되어야 한다.  
그러므로 내부 for문에서 조건을 `let j = i + 1;`로 설정한 것이다.  
2개를 뽑는 것이므로 2개의 for문이 구성될 수 있다.  
재귀함수를 이용해선 아래와 같이 작성 가능하다.

<br/>

```js
let input = [1, 2, 3, 4];
let output = [];
let count = 0;

function combination(arr, data, s, idx, r) {
  if (s == r) {
    count++;
    console.log(data);
    return;
  }

  for (let i = idx; arr.length - i >= r - s; i++) {
    data[s] = arr[i];
    combination(arr, data, s + 1, i + 1, r);
  }
}

combination(input, output, 0, 0, 2);
console.log(count);
```

<br/>
<br/>
<br/>
<br/>

### 👷 점화식

**`점화식`** 은 수열에서 이웃하는 두 항들 간에 성립하는 관계를 나타낸 관계식이다.  
**`등차 수열`** 은 각 항마다 어떤 수가 더해지는 것이고,  
**`등비 수열`** 은 각 항마다 어떤 수가 곱해지는 것이다.  
이 어떤 수는 상수이며, 고정된 값이다.  
특이하게 F(n) = F(n - 1) + F(n - 2)의 관계가 성립하는 수열을  
**`피보나치 수열`** 이라고 한다.

<br/>

먼저 **`등차수열`** 부터 코드로 연습해보았다.

```js
let result;

function forloop(s, t, number) {
  let acc = 0;

  for (let i = 1; i <= number; i++) {
    if (i == 1) {
      acc += s;
    } else {
      acc += t;
    }

    console.log(i, acc);
  }
  return acc;
}

result = forloop(3, 2, 5);
console.log(result);
```

<br/>

위 코드의 `forloop(3, 2, 5)`는  
3부터 시작하여 2만큼을 증가시키는 수열의 5번째 항을 구하는 것이다.  
i가 1부터 시작하여 5까지 반복한다.  
i가 1일 때 `acc += s;`를 해준 것은,  
s가 시작항이므로 첫번째 항을 나타내준 것이다.  
그 뒤부터 t만큼 증가하는 등차수열이므로  
남은 4번을 t를 증가시켜주고 acc를 반환하면 된다.  
다르게 작성할 수도 있었다.

<br/>

```js
let result;

function recursive(s, t, number) {
  if (number == 1) {
    return s;
  }

  return recursive(s, t, number - 1) + t;
}

result = recursive(3, 2, 5);
console.log(result);
```

<br/>

이 코드는 재귀함수를 이용한 것이었는데,  
number가 1이면 첫번째 항 그대로를 나타내므로 s를 반환한다.  
그 다음으로는 number를 1씩 줄여나가며 재귀 호출을 한다.  
`recursive(s, t, n)`은 계속 줄어나가며 호출되고,  
스택이 모두 종료되면서 누적되었던 `+t` 값이 1부터 number까지 더해지는 형식이다.

<br/>

자세하게 적으면서 연습해보자.  
`recursive()`는 간단히 `r()`이라고 쓴다.  
r(3, 2, 5) = r(3, 2, 4) + 2,  
r(3, 2, 4) = r(3, 2, 3) + 2,  
r(3, 2, 3) = r(3, 2, 2) + 2,  
r(3, 2, 2) = r(3, 2, 1) + 2,  
r(3, 2, 1) = return s (return 3)가 된다.  
그러면 r(3, 2, 2)는 5, r(3, 2, 3)은 7,  
r(3, 2, 4)는 9, **최종적으로 r(3, 2, 5)는 11이 된다.**

<br/>

값을 하나하나 대입해보면 해당 알고리즘이 이해는 되지만,  
코드를 곧바로 작성하기엔 아직 매우 어려운 것 같다.  
오늘 하루뿐이 아닌 며칠 간의 공부가 필요해 보인다.

<br/>
<br/>
<br/>
<br/>

### 👷 기본 문제 풀이 - 등차수열의 항 찾기

**입력된 값을 통해서 등차수열의 몇 번째 항인지 구하는 프로그램을 작성하라.**

- 입력은 초항 a, 인접한 차이 d, 찾는 항의 수 n이 주어지며, n 값에 해당하는 항 번호를 반환한다.
- 단, 항 번호가 없다면 -1을 반환한다.
- 예를 들어 a=1, d=2, n=7이 주어졌을 때 f(1)=1, f(2)=3, f(3)=5, f(4)=7이 되므로 n=7에 해당하는 항인 4를 반환한다.

<br/>
<br/>

📕 **나의 풀이**

```js
function answer(a, d, n) {
  let index = -1;

  // 코드 구현 시작 영역

  // 1. 첫 항은 a, 등차는 d, 인덱스를 구해야 할 수는 n이다.
  // 2. n = a + d * rep이다.
  // 2.1. rep이 1이면 n은 2번째 항이다.
  // 3. 즉 7을 찾는 인덱스는 rep + 1이 된다.
  // 4. 언제 끝날지 모르는 반복문이므로 범위를 제한하지 않는다.
  // 5. 등차만큼 계속 더해보며 해당 항을 찾고, 없으면 -1을 리턴한다.
  // 5.1. 해당 항의 값이 n과 다르면서 커져버리면 break 하고 초기 index값(-1)을 return한다.
  // 5.2. 해당 값이 동일하면 인덱스를 재지정하고 break 한다.

  let num;

  for (let i = 1; ; i++) {
    num = a + d * (i - 1);

    if (num > n) {
      break;
    } else if (num == n) {
      index = i;
      break;
    }
  }

  // 코드 구현 종료 영역

  return index;
}
```

<br/>
<br/>

📗 **권장 풀이**

```js
function answer(a, d, n) {
  let index = -1;

  if ((n - a) % d == 0) {
    index = (n - a) / d + 1;
  } else index = -1;

  return index;
}
```

<br/>
<br/>

📘 **코멘트**  
등차가 n-1번 더해지면 n번째 항의 값이 나온다고 생각하고 풀었다.  
그래서 순차적으로 n번째 항의 값을 구하고,  
그 항이 해당 등차수열에 없다면 (범위를 넘어서면) -1을 반환하고,  
해당 값이 있는 경우 인덱스를 출력하도록 했다.

<br/>

**권장 풀이**는 신기하게도 인덱스에 대한 식으로 바로 정의했는데,  
`n항의 값 = 초항 + 등차 x (인덱스 - 1)`를  
`i = (n항의 값 - 초항 / 등차) + 1`로 변환해서  
바로 index를 구하는 식으로 풀어주셨다.  
그래서 등차수열에서 가능한 항의 값인 경우 index를 반환하고,  
아닌 경우 -1을 반환하는 것으로 이해하였다.  
사실상 항목을 처음부터 순회하며 반복할 필요성이 없다고 느꼈다.

<br/>
<br/>
<br/>
<br/>

### 👷 기본 문제 풀이 - 잃어버린 카드 찾기

**등차 수열을 이루는 4개의 숫자 카드 중 잃어버린 하나의 카드를 찾아주자.**

- 입력은 자연수로 된 3개의 숫자카드를 받고, 한 가지의 잃어버린 카드의 수를 반환한다.
- 단, 잃어버린 카드는 가운데 숫자 카드로 한정한다.
- 예를 들어 1, 7, 10을 입력 받았을 때 초항이 1이고 두 수의 차가 3인 등차수열 1, 4, 7, 10을 찾아 4를 반환하도록 한다.

<br/>
<br/>

📕 **나의 풀이**

```js
function answer(a, b, c) {
  let number = 0;

  // sort
  num = [a, b, c];
  num.sort((x, y) => x - y);

  // 코드 구현 시작 영역

  // 조건. 가운데 항이 빠졌다고 전제되었다.

  // 1. 등차를 알아야 한다.
  // 2. 등차는 뒤 항과 앞 항과의 차이인데, 배열의 길이는 3이다.
  // 3. [3, x, 7, 9]가 원래 배열이라고 하면 [3, 7, 9]를 2번처럼 뺀 값들은 4, 2가 나온다.
  // 이 합은 6이며, 4는 2+2가 포함된 것이므로 원래 배열의 길이로 나눠준다.
  // 즉 2 + 2 + 2 / 3을 한 것이 등차이다.
  // 4. 만약 뒤에서 앞 항을 뺀 값들이 앞쪽이 더 크다면, 앞 쪽의 카드를 잃어버린 것이다.
  // 4.1. [1, 7, 10]은 6, 3의 차를 보이므로 2번째 항이 빠진 것이다. 등차가 1번만 더해진다.
  // 4.2. [3, 8, 18]은 5, 10의 차를 보이므로 3번재 항이 빠진 것이다. 등자가 2번 더해진다.

  // 코드 구현 종료 영역
  let sub = 0;
  for (let i = 1; i < num.length; i++) {
    sub += num[i] - num[i - 1];
  }
  sub /= num.length;

  let index = b - a > c - b ? 2 : 3;
  number = a + sub * (index - 1);

  return number;
}
```

<br/>
<br/>

📗 **권장 풀이**

```js
let d = 0;
for (let i = 1; i < num.length; i++) {
  d += num[i] - num[i - 1];
}
d /= num.length;

// 2. 빈 index 찾기
let index = num[2] - num[1] > num[1] - num[0] ? 2 : 1;

// 3. 이전 값 + d
number = num[0] + d * index;

return number;
```

<br/>
<br/>

📘 **코멘트**  
**권장 풀이**와 크게 다른 로직은 없었지만,  
풀고 나서 생각해보니 전체 길이로 나눠주는 방법 외에  
값들의 차이를 구할 때 더 작은 값이 나오면  
그것이 등차라고 판별하는 방법도 있을 것 같다.  
빈 자리의 등차에 한 번 더 더해진 것이 큰 등차이기 때문이다.  
즉 큰 등차값은 원래 등차값의 2배였던 것이다.

<br/>
<br/>
<br/>
<br/>
