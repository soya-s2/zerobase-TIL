# 2021-10-01-Fri

<br/>

## 7. 수학 실전문제풀이 - 1

이 때까지 배운 수학 기본 개념과 문법을 활용해서  
프로그래머스 Lv.1의 12문제를 풀어보기로 했다.  
일단 시간을 두고 최대 30분까지 풀어보며 생각하고,  
다른 풀이와 비교하며 배우기로 하였다.  
다른 풀이는 이웅모 강사님의 부가 설명을 토대로 작성하였다.

<br/>
<br/>
<br/>

### 👻 1. 문자열을 정수로 바꾸기 (형 변환)

#### 문제 설명

문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요.

<br/>

#### 제한 조건

- s의 길이는 1 이상 5이하입니다.
- s의 맨앞에는 부호(+, -)가 올 수 있습니다.
- s는 부호와 숫자로만 이루어져있습니다.
- s는 "0"으로 시작하지 않습니다.

<br/>

#### 입출력 예

예를들어 str이 "1234"이면 1234를 반환하고, "-1234"이면 -1234를 반환하면 됩니다.  
str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(s) {
  return Number(s);
}
```

<br/>
<br/>

📗 **다른 풀이**

```js
function solution(s) {
  return s / 1;
}
```

<br/>
<br/>

📘 **코멘트**  
문자열을 1로 나누면 숫자로 변환된다는 것을 잊고 있었다.

<br/>
<br/>
<br/>

### 👻 2. 짝수와 홀수 (조건문)

#### 문제 설명

정수 num이 짝수일 경우 "Even"을 반환하고 홀수인 경우 "Odd"를 반환하는 함수, solution을 완성해주세요.

<br/>

#### 제한 조건

num은 int 범위의 정수입니다. 0은 짝수입니다.

<br>

#### 입출력 예

`num result`  
3 "Odd"  
4 "Even"

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(num) {
  var answer = "";
  answer = num % 2 == 0 ? "Even" : "Odd";
  return answer;
}
```

<br/>
<br/>

📗 **다른 풀이**

```js
function solution(num) {
  if (num % 2) return "Odd";
  else return "Even";
}
```

<br/>
<br/>

📘 **코멘트**  
삼항연산자와 `if/else`문을 사용할 수 있었다.  
홀수와 짝수의 구분은 기본적으로 나머지가 1인지 0인지로 나눈다.

<br/>
<br/>
<br/>

### 👻 3. 2016년 (조건문)

#### 문제 설명

2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요?  
두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요.  
요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT
입니다.  
**예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 "TUE"를 반환하세요.**

<br/>

#### 제한 조건

- 2016년은 윤년입니다.
- 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)

<br/>

#### 입출력 예

`a b result`  
5 24 "TUE"

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(a, b) {
  var answer = "";
  var date = new Date(`2016-${a}-${b}`);
  var day = date.getDay();

  switch (day) {
    case 0:
      answer = "SUN";
      break;
    case 1:
      answer = "MON";
      break;
    case 2:
      answer = "TUE";
      break;
    case 3:
      answer = "WED";
      break;
    case 4:
      answer = "THU";
      break;
    case 5:
      answer = "FRI";
      break;
    case 6:
      answer = "SAT";
      break;
  }
  return answer;
}
```

<br/>
<br/>

📗 **다른 풀이 1**

```js
let answer,
  day = new Date(2016, a - 1, b).getDay();
```

<br/>

📗 **다른 풀이 2**

```js
return ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"][
  new Date(2016, a - 1, b).getDay()
];
```

<br/>
<br/>

📘 **코멘트**  
Date 객체를 받아온 날짜로 설정해서 `getDay()` 메서드를 사용했다.  
이 외에도 switch 구문의 사용 없이  
배열의 값에 바로 정수 인덱스로 접근하는 방법이 있었다.  
**`new Date(날짜)`를 할 때에 month는 -1로 설정해야 한다.**

<br/>
<br/>
<br/>

### 👻 4. 폰켓몬 (조건문, Set)

#### 문제 설명

당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. **이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.**

**1.** 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택
**2.** 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택
**3.** 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택
**4.** 두 번째(1번), 세 번째(2번) 폰켓몬을 선택
**5.** 두 번째(1번), 네 번째(3번) 폰켓몬을 선택
**6.** 세 번째(2번), 네 번째(3번) 폰켓몬을 선택

<br/>

이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

<br/>

#### 제한사항

- nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.
- nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.
- 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.
- 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, **선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.**

<br/>

#### 입출력 예

`nums result`

[3,1,2,3] 2  
[3,3,3,2,2,4] 3  
[3,3,3,2,2,2] 2

<br/>

#### 입출력 예 설명

##### 입출력 예 #1

문제의 예시와 같습니다.

##### 입출력 예 #2

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.  
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.

##### 입출력 예 #3

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.  
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(nums) {
  var answer = 0;

  // 1. n개의 폰켓몬 중 n/2개를 선택 가능하다.
  // 2. Set으로 중복을 제외한 폰켓몬의 개수를 구한다.
  // 3. 폰켓몬의 개수보다 선택 가능한 갯수가 많으면 폰켓몬의 개수,
  // 폰켓몬의 개수보다 선택 가능한 갯수가 적으면 선택 가능한 개수가 정답이다.

  let select = nums.length / 2;
  let kinds = new Set(nums).size;

  answer = kinds < select ? kinds : select;

  return answer;
}
```

<br/>
<br/>

📗 **다른 풀이**

```js
function solution(nums) {
  const max = nums.length / 2;
  const arr = [...new Set(nums)];

  return arr.length > max ? max : arr.length;
}
```

<br/>
<br/>

📘 **코멘트**  
문제가 굉장히 길어서 읽기 힘들었다.  
일단 제한조건을 잘 확인해야 풀 수 있었다.  
종류가 여러개라도 뽑을 수 있는 종류 갯수의 최댓값만 return하면 된다는 조건이 특히 그러했다.

<br/>

그래서 뽑을 수 있는 갯수보다 폰켓몬의 종류가 많다면 뽑을 수 있는 갯수만큼이,  
뽑을 수 있는 갯수보다 폰켓몬의 종류가 적다면 폰켓몬의 종류 갯수만큼이 해답이 된다.

<br/>

**다른 종류를 뽑으므로 중복이 없어야 해서 `Set`을 사용**한다.  
`Set(nums).size`와 `arr = [...new Set(nums)]`, `arr.length`를 사용하는  
두 가지 방법이 있을 수 있었다.

<br/>
<br/>
<br/>

### 👻 5. 가운데 글자 가져오기 (문자열)

#### 문제 설명

단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요.  
단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.

<br/>

#### 제한사항

s는 길이가 1 이상, 100이하인 스트링입니다.

<br/>

#### 입출력 예

`s return`  
"abcde" "c"  
"qwer" "we"

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(s) {
  var answer = "";

  // 1. s의 길이가 홀수이면 2로 나눈 실수를 버림한 정수 인덱스로 접근한다.
  // 2. s의 길이가 짝수이면 2로 나눈 정수 인덱스의 앞 인덱스부터 1개 뒤에 요소까지 자른다.

  if (s.length % 2 == 1) {
    answer = s[Math.floor(s.length / 2)];
  } else {
    answer = s.slice(s.length / 2 - 1, s.length / 2 + 1);
  }
  return answer;
}
```

<br/>
<br/>

📗 **다른 풀이 1**

```js
function solution(s) {
  return s.substr(Math.round(s.length / 2) - 1, s.length % 2 == 0 ? 2 : 1);
}
```

<br/>

📗 **다른 풀이 2**

```js
function solution(s) {
  return s.slice(parseInt((s.length - 1) / 2), Math.round((s.length + 1) / 2));
}
```

<br/>
<br/>

📘 **코멘트**  
`s.substr(시작 인덱스, n개 만큼까지)`를 이용할 수 있었다.  
나의 경우에는 `Math.floor()`를 써서 일단 소숫점은 버리고 했고,  
다른 풀이는 `Math.round()`로 반올림 후 1을 빼주었다.  
이 외에도 `parseInt()`로 바로 정수화가 가능했고,  
`String.slice()`와 `String.substr()` 두 가지를 사용할 수 있었다.  
개인적으로는 인덱스를 계산하는 것보다 갯수를 적용시키는 것이 편리하다고 느꼈다.

<br/>
<br/>
<br/>

### 👻 6. 문자열 내 마음대로 정렬하기 (문자열, 조건문)

#### 문제 설명

문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 ["sun", "bed", "car"]이고 n이 1이면 각 단어의 인덱스 1의 문자 "u", "e", "a"로 strings를 정렬합니다.

<br/>

#### 제한 조건

- strings는 길이 1 이상, 50이하인 배열입니다.
- strings의 원소는 소문자 알파벳으로 이루어져 있습니다.
- strings의 원소는 길이 1 이상, 100이하인 문자열입니다.
- 모든 strings의 원소의 길이는 n보다 큽니다.
- 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.

<br/>

#### 입출력 예

`strings n return`  
["sun", "bed", "car"] 1 ["car", "bed", "sun"]  
["abce", "abcd", "cdx"] 2 ["abcd", "abce", "cdx"]

<br/>

#### 입출력 예 설명

##### 입출력 예 1

"sun", "bed", "car"의 1번째 인덱스 값은 각각 "u", "e", "a" 입니다. 이를 기준으로 strings를 정렬하면 ["car", "bed", "sun"] 입니다.

##### 입출력 예 2

"abce"와 "abcd", "cdx"의 2번째 인덱스 값은 "c", "c", "x"입니다. 따라서 정렬 후에는 "cdx"가 가장 뒤에 위치합니다. "abce"와 "abcd"는 사전순으로 정렬하면 "abcd"가 우선하므로, 답은 ["abcd", "abce", "cdx"] 입니다.

<br/>
<br/>

📕 **나의 풀이**

```js
function solution(strings, n) {
  // 1. n을 기준으로 문자를 정렬한다.
  // 2. 요소의 n번째 글자가 같은 경우 사전순 정렬한다.
  // 3. 요소의 n번째 글자가 다른 경우 n번째 글자를 기준으로 오름차순 정렬한다.

  return strings.sort((x, y) =>
    x[n] == y[n] ? (x > y ? 1 : -1) : x[n] > y[n] ? 1 : -1
  );
}
```

<br/>
<br/>

📗 **다른 풀이**

```js
function solution(strings, n) {
  return strings.sort((s1, s2) =>
    s1[n] === s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n])
  );
}
```

<br/>
<br/>

📘 **코멘트**  
`String.sort()` 메서드에 함수가 들어가는 것을 잘 몰라서 복습했다.  
일단 배열 안의 숫자들을 넘길 때 `sort((x, y) => x - y)`의 경우  
`1, 10000, 2`와 같은 잘못된 정렬 없이 정렬할 수 있다.

<br/>

그리고 `sort((s1, s2) => s1 > s2 ? 1 : -1)`과 같이 쓰면,  
s1이 s2보다 큰 경우 순서를 바꾼다. (즉 s2가 s1의 앞으로 오도록 한다.)  
`s1 > s2`가 성립하지 않아 -1을 반환하게 되면,  
s1이 s2보다 작다는 뜻이므로 원래의 순서를 유지한다.

<br/>

또한 n번째 인덱스의 문자열이 같은 경우 사전 순대로 정렬하므로,  
같은 경우 `s1.localeCompare(s2)`를,  
다른 경우 `s1[n].localeCompare(s2[n])`을 반환할 수 있다.  
이 `localeCompare()` 메서드는
s1이 s2보다 작은 경우 음수를 반환하고,  
s1이 s2보다 큰 경우 양수를 반환한다.  
(동등한 경우 0을 반환한다.)  
이것이 sort() 메서드 안의 값으로 동작하며 정렬해주는 것이다.  
반환 값은 음/양수라고 해서 정확히 -1이나 1이 아닐 수도 있다고 한다.

<br/>

아래 공식문서를 참고하였다. (메모)

<br/>

> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

<br/>

> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare

<br/>
<br/>
<br/>
